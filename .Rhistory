## Ricks plots by area ----
p4 <- ggplot( ) +
geom_line(data = data.frame(proposed_i[,,1]), aes(x = Fv, y = Yield, col = 'Area 1') ) +
geom_line(data = data.frame(proposed_i[,,2]), aes(x = Fv, y = Yield, col = 'Area 2') ) +
geom_line(data = data.frame(proposed_i[,,3]), aes(x = Fv, y = Yield, col = 'Area 3') ) +
labs(x = 'F', color = 'Area', title = 'Yield vs F by Area') +
theme_sleek() +theme(legend.position = 'none')
# geom_vline(xintercept = Ftest[which(proposed_i[,2,1] > proposed_i[,3,1])[1]]) #+ ## where Y > B in area 1
# geom_vline(xintercept = Ftest[which.max(proposed_i[,2,3])]) ## where Y > B in area 1
# b <- which(proposed_i[,2,2] > proposed_i[,3,2])[1]
# b <- which.max(proposed_i[,2,3])
p5 <- ggplot( ) +
geom_line(data = data.frame(proposed_i[,,1]), aes(x = B, y = Yield, col = 'Area 1') ) +
geom_line(data = data.frame(proposed_i[,,2]), aes(x = B, y = Yield, col = 'Area 2') ) +
geom_line(data = data.frame(proposed_i[,,3]), aes(x = B, y = Yield, col = 'Area 3') ) +
labs(x = 'B', color = 'Area', title = 'Yield  vs B by Area') +
theme_sleek() #+
# geom_vline(xintercept = Ftest[which.max(proposed_i[,2,3])]) ## where Y > B in area 1
p6 <- ggplot( ) +
geom_line(data = data.frame(proposed_i[,,1]), aes(x = Fv, y = B, col = 'Area 1') ) +
geom_line(data = data.frame(proposed_i[,,2]), aes(x = Fv, y = B, col = 'Area 2') ) +
geom_line(data = data.frame(proposed_i[,,3]), aes(x = Fv, y = B, col = 'Area 3') ) +
labs(x = 'F', color = 'Area', title = 'B vs F by Area') +
theme_sleek() +theme(legend.position = c(0.8,0.8))
(p4  |p5  |p6)
prop$SB_i[i]/(rleveltmp*rdistUse[i])
prop$SB_i[i]
rleveltmp*rdistUse[i]
rleveltmp
rlevelUse
prop$Yield_i
prop$SB_i
Yield_Ri
Equil_Spawn_Recr_Fxn(steepness = steep[i], SSB_virgin = SB0_i[i],
Recr_virgin = R0[i], SPR_temp = SB_Ri[v,i])
SB_Ri
maxiter = 50
for(v in 1:length(Ftest)){
# if(v %% 10 == 0) cat(v,"\n")
for(k in 1:maxiter){ ## Loop over steps A & B
if(k == 1){
rdistUse <- recr_dist ## no distribution now; full rec-level in each area
rlevelUse = rec_level ## pre-specified No recruits in area, currently R0
} else{
rdistUse <- recr_dist ## only after computing R_i
rlevelUse =   list(rec_level,
rick[v,'R_ESUMB'],
rick[v,'R_SUMEBA'],
R_eq_i[v,],
sum(R_eq_i[v,])*nominal_dist)[[4]]
}
# cat(rlevelUse,"\n")
# if(k == 10  |k == 9 ) cat(v,"\t",k,"\t",paste(round(rlevelUse)),"\n") ## monitoring if this changes
## define virgin biomass by AREA
SB0_i <- doNage(Fv = rep(0,narea),
X = X_ija,
rdist = rdistUse,
refR = rlevelUse)$SB_i
## get values at present Fv
# In each iteration, calculate the SSB and Yield that
# comes from those recruits, taking movement into account
prop <- doNage( Fv = rep(Ftest[v],narea),
X = X_ija,
rdist = rdistUse,
refR = rlevelUse)
# radj[k,v,] <- rlevelUse
# call Equ_Spawn_Recr_Fxn for each area to get B_equil and R_equil from SPB/R and SR parms
for(i in 1:narea){ ## will overwrite second time
# calc area-specific SPB/R and Yield/R, using area-specific R
if(length(rlevelUse) > 1){
rleveltmp = list(rlevelUse[i],
min(rlevelUse[i],R0[i]),
max(rlevelUse[i],R0[i]),
max(rlevelUse[i],1))[[1]]
#  if(rlevelUse[i] > R0[i]){
#    rleveltmp = R0[i]
#  } else if(rlevelUse[i] <1){
#    rleveltmp = 1
#  }
} else{
rleveltmp = rlevelUse
}
# if(k %% 10 == 0 | k %% 3 == 0) cat(v, k,i,round(rleveltmp),"\n")
radj[k,v,i] <- rleveltmp
# if(round(prop$Yield_i[i],3) == 0) prop$Yield_i[i] <- 0
# prop$Yield_i[i] <- round(prop$Yield_i[i],3) ## avoid div by small numbers and get weirdstuff
# prop$SB_i[i] <- round(prop$SB_i[i],3) ## avoid div by small numbers and get weirdstuff
SB_Ri[v,i] <- prop$SB_i[i]/(rleveltmp*rdistUse[i]) ## on k = 1 will just be rleveltemp
Yield_Ri[v,i] <- prop$Yield_i[i]/(rleveltmp*rdistUse[i])
if(k %% 10 == 0 ) cat(v, k,i,  Yield_Ri[v,i],"\n")
## Calc area-specific recruits using area-specific SB etc
propEq <- Equil_Spawn_Recr_Fxn(steepness = steep[i], SSB_virgin = SB0_i[i],
Recr_virgin = R0[i], SPR_temp = SB_Ri[v,i])
B_eq_i[v,i] <- propEq$B_equil
R_eq_i[v,i] <- propEq$R_equil ## gets overwritten each iteration
if(k == maxiter){ ## store quantities
proposed_i[v,'Fv',i] <- Ftest[v]
proposed_i[v,'Yield',i] <-  Yield_Ri[v,i]*R_eq_i[v,i]
proposed_i[v,'B',i] <-    SB_Ri[v,i] *R_eq_i[v,i]
} ## end k max
} ## end areas
if(k == maxiter){ ## store quantities
## storing info, not currently used
rick[v,"Fv"] <- Ftest[v]
rick[v,"SBeqtotal"] <-   sum(B_eq_i[v,] )
## sum of expected recruits in areas
rick[v,"R_SUMEBA"]  <- sum( R_eq_i[v,])
}
} ## end k:maxiter
proposed[v,'Fv'] <- Ftest[v]
proposed[v,'Yield'] <-   sum(proposed_i[v,'Yield',])# sum(Yield_Ri[v,] * R_eq_i[v,]) # sum(Yield_Ri[v,]) * sum(R_eq_i[v,])
proposed[v,'B'] <-  sum(proposed_i[v,'B',])#sum(SB_Ri[v,] *  R_eq_i[v,i])  #sum(SB_Ri[v,]) * sum(B_eq_i[v,])
} ## end FV
## Ricks plots by area ----
p4 <- ggplot( ) +
geom_line(data = data.frame(proposed_i[,,1]), aes(x = Fv, y = Yield, col = 'Area 1') ) +
geom_line(data = data.frame(proposed_i[,,2]), aes(x = Fv, y = Yield, col = 'Area 2') ) +
geom_line(data = data.frame(proposed_i[,,3]), aes(x = Fv, y = Yield, col = 'Area 3') ) +
labs(x = 'F', color = 'Area', title = 'Yield vs F by Area') +
theme_sleek() +theme(legend.position = 'none')
# geom_vline(xintercept = Ftest[which(proposed_i[,2,1] > proposed_i[,3,1])[1]]) #+ ## where Y > B in area 1
# geom_vline(xintercept = Ftest[which.max(proposed_i[,2,3])]) ## where Y > B in area 1
# b <- which(proposed_i[,2,2] > proposed_i[,3,2])[1]
# b <- which.max(proposed_i[,2,3])
p5 <- ggplot( ) +
geom_line(data = data.frame(proposed_i[,,1]), aes(x = B, y = Yield, col = 'Area 1') ) +
geom_line(data = data.frame(proposed_i[,,2]), aes(x = B, y = Yield, col = 'Area 2') ) +
geom_line(data = data.frame(proposed_i[,,3]), aes(x = B, y = Yield, col = 'Area 3') ) +
labs(x = 'B', color = 'Area', title = 'Yield  vs B by Area') +
theme_sleek() #+
# geom_vline(xintercept = Ftest[which.max(proposed_i[,2,3])]) ## where Y > B in area 1
p6 <- ggplot( ) +
geom_line(data = data.frame(proposed_i[,,1]), aes(x = Fv, y = B, col = 'Area 1') ) +
geom_line(data = data.frame(proposed_i[,,2]), aes(x = Fv, y = B, col = 'Area 2') ) +
geom_line(data = data.frame(proposed_i[,,3]), aes(x = Fv, y = B, col = 'Area 3') ) +
labs(x = 'F', color = 'Area', title = 'B vs F by Area') +
theme_sleek() +theme(legend.position = c(0.8,0.8))
(p4  |p5  |p6)
v
v = 120
# if(v %% 10 == 0) cat(v,"\n")
for(k in 1:maxiter){ ## Loop over steps A & B
if(k == 1){
rdistUse <- recr_dist ## no distribution now; full rec-level in each area
rlevelUse = rec_level ## pre-specified No recruits in area, currently R0
} else{
rdistUse <- recr_dist ## only after computing R_i
rlevelUse =   list(rec_level,
rick[v,'R_ESUMB'],
rick[v,'R_SUMEBA'],
R_eq_i[v,],
sum(R_eq_i[v,])*nominal_dist)[[4]]
}
# cat(rlevelUse,"\n")
# if(k == 10  |k == 9 ) cat(v,"\t",k,"\t",paste(round(rlevelUse)),"\n") ## monitoring if this changes
## define virgin biomass by AREA
SB0_i <- doNage(Fv = rep(0,narea),
X = X_ija,
rdist = rdistUse,
refR = rlevelUse)$SB_i
## get values at present Fv
# In each iteration, calculate the SSB and Yield that
# comes from those recruits, taking movement into account
prop <- doNage( Fv = rep(Ftest[v],narea),
X = X_ija,
rdist = rdistUse,
refR = rlevelUse)
# radj[k,v,] <- rlevelUse
# call Equ_Spawn_Recr_Fxn for each area to get B_equil and R_equil from SPB/R and SR parms
for(i in 1:narea){ ## will overwrite second time
# calc area-specific SPB/R and Yield/R, using area-specific R
if(length(rlevelUse) > 1){
rleveltmp = list(rlevelUse[i],
min(rlevelUse[i],R0[i]),
max(rlevelUse[i],R0[i]),
max(rlevelUse[i],1))[[1]]
#  if(rlevelUse[i] > R0[i]){
#    rleveltmp = R0[i]
#  } else if(rlevelUse[i] <1){
#    rleveltmp = 1
#  }
} else{
rleveltmp = rlevelUse
}
# if(k %% 10 == 0 | k %% 3 == 0) cat(v, k,i,round(rleveltmp),"\n")
radj[k,v,i] <- rleveltmp
# if(round(prop$Yield_i[i],3) == 0) prop$Yield_i[i] <- 0
# prop$Yield_i[i] <- round(prop$Yield_i[i],3) ## avoid div by small numbers and get weirdstuff
# prop$SB_i[i] <- round(prop$SB_i[i],3) ## avoid div by small numbers and get weirdstuff
SB_Ri[v,i] <- prop$SB_i[i]/(rleveltmp*rdistUse[i]) ## on k = 1 will just be rleveltemp
Yield_Ri[v,i] <- prop$Yield_i[i]/(rleveltmp*rdistUse[i])
if(k %% 10 == 0 ) cat(v, k,i,  Yield_Ri[v,i],"\n")
## Calc area-specific recruits using area-specific SB etc
propEq <- Equil_Spawn_Recr_Fxn(steepness = steep[i], SSB_virgin = SB0_i[i],
Recr_virgin = R0[i], SPR_temp = SB_Ri[v,i])
B_eq_i[v,i] <- propEq$B_equil
R_eq_i[v,i] <- propEq$R_equil ## gets overwritten each iteration
if(k == maxiter){ ## store quantities
proposed_i[v,'Fv',i] <- Ftest[v]
proposed_i[v,'Yield',i] <-  Yield_Ri[v,i]*R_eq_i[v,i]
proposed_i[v,'B',i] <-    SB_Ri[v,i] *R_eq_i[v,i]
} ## end k max
} ## end areas
if(k == maxiter){ ## store quantities
## storing info, not currently used
rick[v,"Fv"] <- Ftest[v]
rick[v,"SBeqtotal"] <-   sum(B_eq_i[v,] )
## sum of expected recruits in areas
rick[v,"R_SUMEBA"]  <- sum( R_eq_i[v,])
}
} ## end k:maxiter
for(v in 1:length(Ftest)){
# if(v %% 10 == 0) cat(v,"\n")
for(k in 1:maxiter){ ## Loop over steps A & B
if(k == 1){
rdistUse <- recr_dist ## no distribution now; full rec-level in each area
rlevelUse = rec_level ## pre-specified No recruits in area, currently R0
} else{
rdistUse <- recr_dist ## only after computing R_i
rlevelUse =   list(rec_level,
rick[v,'R_ESUMB'],
rick[v,'R_SUMEBA'],
R_eq_i[v,],
sum(R_eq_i[v,])*nominal_dist)[[4]]
}
# cat(rlevelUse,"\n")
# if(k == 10  |k == 9 ) cat(v,"\t",k,"\t",paste(round(rlevelUse)),"\n") ## monitoring if this changes
## define virgin biomass by AREA
SB0_i <- doNage(Fv = rep(0,narea),
X = X_ija,
rdist = rdistUse,
refR = rlevelUse)$SB_i
## get values at present Fv
# In each iteration, calculate the SSB and Yield that
# comes from those recruits, taking movement into account
prop <- doNage( Fv = rep(Ftest[v],narea),
X = X_ija,
rdist = rdistUse,
refR = rlevelUse)
# radj[k,v,] <- rlevelUse
# call Equ_Spawn_Recr_Fxn for each area to get B_equil and R_equil from SPB/R and SR parms
for(i in 1:narea){ ## will overwrite second time
# calc area-specific SPB/R and Yield/R, using area-specific R
if(length(rlevelUse) > 1){
rleveltmp = list(rlevelUse[i],
min(rlevelUse[i],R0[i]),
max(rlevelUse[i],R0[i]),
max(rlevelUse[i],1))[[1]]
#  if(rlevelUse[i] > R0[i]){
#    rleveltmp = R0[i]
#  } else if(rlevelUse[i] <1){
#    rleveltmp = 1
#  }
} else{
rleveltmp = rlevelUse
}
if(k %% 10 == 0 | k %% 3 == 0) cat(v, k,i,round(rleveltmp),"\n")
radj[k,v,i] <- rleveltmp
# if(round(prop$Yield_i[i],3) == 0) prop$Yield_i[i] <- 0
# prop$Yield_i[i] <- round(prop$Yield_i[i],3) ## avoid div by small numbers and get weirdstuff
# prop$SB_i[i] <- round(prop$SB_i[i],3) ## avoid div by small numbers and get weirdstuff
SB_Ri[v,i] <- prop$SB_i[i]/(rleveltmp*rdistUse[i]) ## on k = 1 will just be rleveltemp
Yield_Ri[v,i] <- prop$Yield_i[i]/(rleveltmp*rdistUse[i])
# if(k %% 10 == 0 ) cat(v, k,i,  Yield_Ri[v,i],"\n")
## Calc area-specific recruits using area-specific SB etc
propEq <- Equil_Spawn_Recr_Fxn(steepness = steep[i], SSB_virgin = SB0_i[i],
Recr_virgin = R0[i], SPR_temp = SB_Ri[v,i])
B_eq_i[v,i] <- propEq$B_equil
R_eq_i[v,i] <- propEq$R_equil ## gets overwritten each iteration
if(k == maxiter){ ## store quantities
proposed_i[v,'Fv',i] <- Ftest[v]
proposed_i[v,'Yield',i] <-  Yield_Ri[v,i]*R_eq_i[v,i]
proposed_i[v,'B',i] <-    SB_Ri[v,i] *R_eq_i[v,i]
} ## end k max
} ## end areas
if(k == maxiter){ ## store quantities
## storing info, not currently used
rick[v,"Fv"] <- Ftest[v]
rick[v,"SBeqtotal"] <-   sum(B_eq_i[v,] )
## sum of expected recruits in areas
rick[v,"R_SUMEBA"]  <- sum( R_eq_i[v,])
}
} ## end k:maxiter
proposed[v,'Fv'] <- Ftest[v]
proposed[v,'Yield'] <-   sum(proposed_i[v,'Yield',])# sum(Yield_Ri[v,] * R_eq_i[v,]) # sum(Yield_Ri[v,]) * sum(R_eq_i[v,])
proposed[v,'B'] <-  sum(proposed_i[v,'B',])#sum(SB_Ri[v,] *  R_eq_i[v,i])  #sum(SB_Ri[v,]) * sum(B_eq_i[v,])
} ## end FV
v = 120
# if(v %% 10 == 0) cat(v,"\n")
for(k in 1:maxiter){ ## Loop over steps A & B
if(k == 1){
rdistUse <- recr_dist ## no distribution now; full rec-level in each area
rlevelUse = rec_level ## pre-specified No recruits in area, currently R0
} else{
rdistUse <- recr_dist ## only after computing R_i
rlevelUse =   list(rec_level,
rick[v,'R_ESUMB'],
rick[v,'R_SUMEBA'],
R_eq_i[v,],
sum(R_eq_i[v,])*nominal_dist)[[4]]
}
# cat(rlevelUse,"\n")
# if(k == 10  |k == 9 ) cat(v,"\t",k,"\t",paste(round(rlevelUse)),"\n") ## monitoring if this changes
## define virgin biomass by AREA
SB0_i <- doNage(Fv = rep(0,narea),
X = X_ija,
rdist = rdistUse,
refR = rlevelUse)$SB_i
## get values at present Fv
# In each iteration, calculate the SSB and Yield that
# comes from those recruits, taking movement into account
prop <- doNage( Fv = rep(Ftest[v],narea),
X = X_ija,
rdist = rdistUse,
refR = rlevelUse)
# radj[k,v,] <- rlevelUse
# call Equ_Spawn_Recr_Fxn for each area to get B_equil and R_equil from SPB/R and SR parms
for(i in 1:narea){ ## will overwrite second time
# calc area-specific SPB/R and Yield/R, using area-specific R
if(length(rlevelUse) > 1){
rleveltmp = list(rlevelUse[i],
min(rlevelUse[i],R0[i]),
max(rlevelUse[i],R0[i]),
max(rlevelUse[i],1))[[1]]
#  if(rlevelUse[i] > R0[i]){
#    rleveltmp = R0[i]
#  } else if(rlevelUse[i] <1){
#    rleveltmp = 1
#  }
} else{
rleveltmp = rlevelUse
}
if(k %% 10 == 0 | k %% 3 == 0) cat(v, k,i,round(rleveltmp),"\n")
radj[k,v,i] <- rleveltmp
# if(round(prop$Yield_i[i],3) == 0) prop$Yield_i[i] <- 0
# prop$Yield_i[i] <- round(prop$Yield_i[i],3) ## avoid div by small numbers and get weirdstuff
# prop$SB_i[i] <- round(prop$SB_i[i],3) ## avoid div by small numbers and get weirdstuff
SB_Ri[v,i] <- prop$SB_i[i]/(rleveltmp*rdistUse[i]) ## on k = 1 will just be rleveltemp
Yield_Ri[v,i] <- prop$Yield_i[i]/(rleveltmp*rdistUse[i])
# if(k %% 10 == 0 ) cat(v, k,i,  Yield_Ri[v,i],"\n")
## Calc area-specific recruits using area-specific SB etc
propEq <- Equil_Spawn_Recr_Fxn(steepness = steep[i], SSB_virgin = SB0_i[i],
Recr_virgin = R0[i], SPR_temp = SB_Ri[v,i])
B_eq_i[v,i] <- propEq$B_equil
R_eq_i[v,i] <- propEq$R_equil ## gets overwritten each iteration
if(k == maxiter){ ## store quantities
proposed_i[v,'Fv',i] <- Ftest[v]
proposed_i[v,'Yield',i] <-  Yield_Ri[v,i]*R_eq_i[v,i]
proposed_i[v,'B',i] <-    SB_Ri[v,i] *R_eq_i[v,i]
} ## end k max
} ## end areas
if(k == maxiter){ ## store quantities
## storing info, not currently used
rick[v,"Fv"] <- Ftest[v]
rick[v,"SBeqtotal"] <-   sum(B_eq_i[v,] )
## sum of expected recruits in areas
rick[v,"R_SUMEBA"]  <- sum( R_eq_i[v,])
}
} ## end k:maxiter
maxiter = 100
# if(v %% 10 == 0) cat(v,"\n")
for(k in 1:maxiter){ ## Loop over steps A & B
if(k == 1){
rdistUse <- recr_dist ## no distribution now; full rec-level in each area
rlevelUse = rec_level ## pre-specified No recruits in area, currently R0
} else{
rdistUse <- recr_dist ## only after computing R_i
rlevelUse =   list(rec_level,
rick[v,'R_ESUMB'],
rick[v,'R_SUMEBA'],
R_eq_i[v,],
sum(R_eq_i[v,])*nominal_dist)[[4]]
}
# cat(rlevelUse,"\n")
# if(k == 10  |k == 9 ) cat(v,"\t",k,"\t",paste(round(rlevelUse)),"\n") ## monitoring if this changes
## define virgin biomass by AREA
SB0_i <- doNage(Fv = rep(0,narea),
X = X_ija,
rdist = rdistUse,
refR = rlevelUse)$SB_i
## get values at present Fv
# In each iteration, calculate the SSB and Yield that
# comes from those recruits, taking movement into account
prop <- doNage( Fv = rep(Ftest[v],narea),
X = X_ija,
rdist = rdistUse,
refR = rlevelUse)
# radj[k,v,] <- rlevelUse
# call Equ_Spawn_Recr_Fxn for each area to get B_equil and R_equil from SPB/R and SR parms
for(i in 1:narea){ ## will overwrite second time
# calc area-specific SPB/R and Yield/R, using area-specific R
if(length(rlevelUse) > 1){
rleveltmp = list(rlevelUse[i],
min(rlevelUse[i],R0[i]),
max(rlevelUse[i],R0[i]),
max(rlevelUse[i],1))[[1]]
#  if(rlevelUse[i] > R0[i]){
#    rleveltmp = R0[i]
#  } else if(rlevelUse[i] <1){
#    rleveltmp = 1
#  }
} else{
rleveltmp = rlevelUse
}
if(k %% 10 == 0 | k %% 3 == 0) cat(v, k,i,round(rleveltmp),"\n")
radj[k,v,i] <- rleveltmp
# if(round(prop$Yield_i[i],3) == 0) prop$Yield_i[i] <- 0
# prop$Yield_i[i] <- round(prop$Yield_i[i],3) ## avoid div by small numbers and get weirdstuff
# prop$SB_i[i] <- round(prop$SB_i[i],3) ## avoid div by small numbers and get weirdstuff
SB_Ri[v,i] <- prop$SB_i[i]/(rleveltmp*rdistUse[i]) ## on k = 1 will just be rleveltemp
Yield_Ri[v,i] <- prop$Yield_i[i]/(rleveltmp*rdistUse[i])
# if(k %% 10 == 0 ) cat(v, k,i,  Yield_Ri[v,i],"\n")
## Calc area-specific recruits using area-specific SB etc
propEq <- Equil_Spawn_Recr_Fxn(steepness = steep[i], SSB_virgin = SB0_i[i],
Recr_virgin = R0[i], SPR_temp = SB_Ri[v,i])
B_eq_i[v,i] <- propEq$B_equil
R_eq_i[v,i] <- propEq$R_equil ## gets overwritten each iteration
if(k == maxiter){ ## store quantities
proposed_i[v,'Fv',i] <- Ftest[v]
proposed_i[v,'Yield',i] <-  Yield_Ri[v,i]*R_eq_i[v,i]
proposed_i[v,'B',i] <-    SB_Ri[v,i] *R_eq_i[v,i]
} ## end k max
} ## end areas
if(k == maxiter){ ## store quantities
## storing info, not currently used
rick[v,"Fv"] <- Ftest[v]
rick[v,"SBeqtotal"] <-   sum(B_eq_i[v,] )
## sum of expected recruits in areas
rick[v,"R_SUMEBA"]  <- sum( R_eq_i[v,])
}
} ## end k:maxiter
radj <- array(NA, dim = c(maxiter,length(Ftest),3)) ## keeping track of convergence
for(v in 1:length(Ftest)){
# if(v %% 10 == 0) cat(v,"\n")
for(k in 1:maxiter){ ## Loop over steps A & B
if(k == 1){
rdistUse <- recr_dist ## no distribution now; full rec-level in each area
rlevelUse = rec_level ## pre-specified No recruits in area, currently R0
} else{
rdistUse <- recr_dist ## only after computing R_i
rlevelUse =   list(rec_level,
rick[v,'R_ESUMB'],
rick[v,'R_SUMEBA'],
R_eq_i[v,],
sum(R_eq_i[v,])*nominal_dist)[[4]]
}
# cat(rlevelUse,"\n")
# if(k == 10  |k == 9 ) cat(v,"\t",k,"\t",paste(round(rlevelUse)),"\n") ## monitoring if this changes
## define virgin biomass by AREA
SB0_i <- doNage(Fv = rep(0,narea),
X = X_ija,
rdist = rdistUse,
refR = rlevelUse)$SB_i
## get values at present Fv
# In each iteration, calculate the SSB and Yield that
# comes from those recruits, taking movement into account
prop <- doNage( Fv = rep(Ftest[v],narea),
X = X_ija,
rdist = rdistUse,
refR = rlevelUse)
# radj[k,v,] <- rlevelUse
# call Equ_Spawn_Recr_Fxn for each area to get B_equil and R_equil from SPB/R and SR parms
for(i in 1:narea){ ## will overwrite second time
# calc area-specific SPB/R and Yield/R, using area-specific R
if(length(rlevelUse) > 1){
rleveltmp = list(rlevelUse[i],
min(rlevelUse[i],R0[i]),
max(rlevelUse[i],R0[i]),
max(rlevelUse[i],1))[[1]]
#  if(rlevelUse[i] > R0[i]){
#    rleveltmp = R0[i]
#  } else if(rlevelUse[i] <1){
#    rleveltmp = 1
#  }
} else{
rleveltmp = rlevelUse
}
if(k %% 10 == 0 | k %% 3 == 0) cat(v, k,i,round(rleveltmp),"\n")
radj[k,v,i] <- rleveltmp
# if(round(prop$Yield_i[i],3) == 0) prop$Yield_i[i] <- 0
# prop$Yield_i[i] <- round(prop$Yield_i[i],3) ## avoid div by small numbers and get weirdstuff
# prop$SB_i[i] <- round(prop$SB_i[i],3) ## avoid div by small numbers and get weirdstuff
SB_Ri[v,i] <- prop$SB_i[i]/(rleveltmp*rdistUse[i]) ## on k = 1 will just be rleveltemp
Yield_Ri[v,i] <- prop$Yield_i[i]/(rleveltmp*rdistUse[i])
# if(k %% 10 == 0 ) cat(v, k,i,  Yield_Ri[v,i],"\n")
## Calc area-specific recruits using area-specific SB etc
propEq <- Equil_Spawn_Recr_Fxn(steepness = steep[i], SSB_virgin = SB0_i[i],
Recr_virgin = R0[i], SPR_temp = SB_Ri[v,i])
B_eq_i[v,i] <- propEq$B_equil
R_eq_i[v,i] <- propEq$R_equil ## gets overwritten each iteration
if(k == maxiter){ ## store quantities
proposed_i[v,'Fv',i] <- Ftest[v]
proposed_i[v,'Yield',i] <-  Yield_Ri[v,i]*R_eq_i[v,i]
proposed_i[v,'B',i] <-    SB_Ri[v,i] *R_eq_i[v,i]
} ## end k max
} ## end areas
if(k == maxiter){ ## store quantities
## storing info, not currently used
rick[v,"Fv"] <- Ftest[v]
rick[v,"SBeqtotal"] <-   sum(B_eq_i[v,] )
## sum of expected recruits in areas
rick[v,"R_SUMEBA"]  <- sum( R_eq_i[v,])
}
} ## end k:maxiter
proposed[v,'Fv'] <- Ftest[v]
proposed[v,'Yield'] <-   sum(proposed_i[v,'Yield',])# sum(Yield_Ri[v,] * R_eq_i[v,]) # sum(Yield_Ri[v,]) * sum(R_eq_i[v,])
proposed[v,'B'] <-  sum(proposed_i[v,'B',])#sum(SB_Ri[v,] *  R_eq_i[v,i])  #sum(SB_Ri[v,]) * sum(B_eq_i[v,])
} ## end FV
rlevelUse
rleveltmp
prop$SB_i[i]/(rleveltmp*rdistUse[i]) ## on
prop$SB_i
